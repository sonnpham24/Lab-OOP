ANSWERS FOR LAB04 QUESTIONS

Name: Pham Cong Son
MSSV: 20205220

9. Constructors of whole classes and parent classes
Question: Which classes are aggregates of other classes? Checking all constructors of whole classes if they initialize for their parts?
Answer:
- Media is the parent (superclass) of all media types (Book, Disc): initializes id, title, category, cost (all parts)
- Book and Disc are aggregates of Media
	+ Book only initializes author
	+ Disc only initializes director, length
- DigitalVideoDisc and CompactDisc are aggregates of Disc
	+ DigitalVideoDisc don't have to initialize any part
	+ CompactDisc only initializes artist, tracks
- Track initializes title, length (all parts for its contructors)

10. Unique item in a list
Question: When overriding the equals() method of the Object class, you will have to cast the Object parameter obj to the type of Object that you are dealing with. For example, in the Media class, you must cast the Object obj to a Media, and then check the equality of the two objectsâ€™ attributes as the above requirements (i.e. title for Media; title and length for Track). If the passing object is not an instance of Media, what happens?
Answer:
If the passing object is not an instance of the expected class (e.g., Media in the Media class or Track in the Track class), the overridden equals() method will return false. This is due to the explicit type-checking step in the implementation:
if (obj == null || getClass() != obj.getClass()) return false;
- if (obj == null):
	If obj is null, the method immediately returns false, because a null object cannot be equal to a valid object.

- if (getClass() != obj.getClass()):
	The getClass() method checks the runtime class of the current object (this) and the passed object (obj).
	If the two classes are not the same, the method returns false. This ensures that only objects of the same class (or exact type) can be compared.

- Casting after Check:
	Once the type check passes, the obj can safely be cast to the desired type (e.g., Media or Track) without causing a ClassCastException.
	If obj is not an instance of the correct class and you try to cast it without type-checking, a runtime error (ClassCastException) will occur.

11. Polymorphism with toString() method
Question: Iterate through the list and print out the information of the media by using toString() method. Observe what happens and explain in detail.
Answer:
- Result in Console:
DVD - The Lion King - Animation - Roger Allers - 87 min: 19.95 $
DVD - Star Wars - Science Fiction - George Lucas - 87 min: 24.95 $
DVD - Aladin - Animation - Unknown - Unknown: 18.99 $
Book - Harry Potter - Fantasy - 39.99 - [J.K. Rowling]
CD - Greatest Hits - Music - Various Artists - John Doe: 15.99 $
Tracks:
- Song 1 (3 min)
- Song 2 (4 min)
Total Length: 7 min

- When calling the method, depending on the type of object (DVDs or Books or CDS), corresponding toString() will be executed. This behavior is due to polymorphism, which allows a subclass to provide its own implementation of a method defined in its superclass.
1. Method Overriding
When a subclass provides its own implementation of a method (e.g., toString()) that is defined in its superclass, this is called method overriding. In Java, toString() is defined in the Object class, and all classes inherit it. By overriding this method, you provide a class-specific behavior.

2. Polymorphism
Java resolves method calls (like toString()) at runtime based on the actual object type, not the reference type. This is called dynamic method dispatch or runtime polymorphism. When you call toString() on a reference, Java checks the actual runtime type of the object the reference is pointing to and invokes the corresponding overridden method.

In conclusion, the toString() method is resolved at runtime. If a class overrides toString(), Java will call the overridden method for objects of that class. If a subclass does not override toString(), it inherits the toString() implementation from its parent class. This allows each class to define its own version of toString(), and the JVM dynamically chooses the appropriate implementation during execution.